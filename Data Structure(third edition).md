
---
# 数据结构(第3版)
---
[toc]

## 第2章 绪论

### 2.1 数据结构概念

   * **数据的逻辑结构**
     线性结构、非线性结构(树、图)
   * **数据的存储结构**
     顺序存储、链接存储、索引存储、散列存储
   * **对数据结构的操作**
     插入、删除、修改、排序、查找

### 2.2 算法

   * **算法及其特性**
     确定、可行、有限、输入、输出
   * **算法的评价标准**
     正确性、时间复杂性、占用空间、可读性、鲁棒性

## 第3章 线性表、堆栈和队列

### 3.1 线性表

1. 线性表的定义和基本操作
   
2. 线性表的顺序存储结构

3. 线性表的链接存储结构
   * 单链表
   * 循环链表
   * 双向链表
  
4. 二者之间的比较
   * 空间效率比较
   * 时间复杂性比较
   * 显然，当经常需要对线性表进行插入、删除操作时，链表的时间效率较高；当经常需要对线性表进行存取且存取操作比插入、删除操作更为频繁时，顺序表的时间效率较高。

### 3.2 堆栈

1. 堆栈的定义和基本操作
   
   * push();
   * pop();
   * peek();
   * clear();
   * IsEmpty();

2. 顺序栈

3. 链式栈

### 3.3 队列

1. 队列的定义和基本操作
   * push();
   * pop();
   * front();
   * IsFull();
   * IsEmpty();

2. 顺序队列

3. 链式队列

## 第4章 数组和字符串

### 4.1 数组和矩阵

### 4.2 字符串

1. 字符串的基本操作
   
   * 串长统计
   * 串定位：返回字符或字符串在母串中首次出现的位置的指针
   * 串复制
   * 串插入
   * 串拼接
   * 串删除

2. 模式匹配算法
   
   * 朴素的模式匹配算法
   * 模式匹配的改进算法


## 第5章 树与二叉树

### 5.1 树的基本概念

* 树的定义
* 树的相关术语
    1. 父亲、儿子、兄弟、后裔、祖先
    2. 度、叶子结点、分支结点
    3. 结点的层数
       * 根的层数为0。
       * 其余结点的层数为其父亲的层数加1。
* 树的表示
     1. 树形表示法
     2. 嵌套集合表示法
     3. 嵌套括号表示法
     4. 凹入表示法

### 5.2 二叉树

#### 5.2.1 二叉树定义和主要性质

定义：二叉树是结点的有限集合，它或者是空集，或者是由一个根及两棵不相交的称为这个根的左、右子树的二叉树组成。

性质：

1. 二叉树中层数为i的结点至多有2^i个。(i>=0)
2. 高度为k的二叉树中至多有2^(k+1)-1个结点。(k>=0)
3. 次数为2的结点个数比叶结点的个数多2。

定义：满二叉树、完全二叉树
性质：具有n个结点的完全二叉树的高度是logn(取地板)。

#### 5.2.2 二叉树顺序存储

比较适合于完全二叉树或者近似完全二叉树，当不是时要添加结点构造完全二叉树，这可能会浪费大量存储空间。

#### 5.2.3 二叉树链接存储

#### 5.2.4 二叉树遍历

1. 先根遍历(递归、非递归)
2. 中根遍历(递归、非递归)
3. 后根遍历(递归、非递归)
4. 层次遍历

#### 5.2.5 二叉树的其他操作

1. 创建二叉树
2. 复制二叉树
3. 查找给定结点的父亲
4. 查找结点
5. 释放二叉树
6. 插入结点

### 5.3 线索二叉树

* 线索二叉树的概念
* 线索二叉树的操作
   1. 查找中根序列的第一个和最后一个结点
   2. 查找中序后继结点和中序前驱结点
   3. 遍历线索二叉树
   4. 插入结点
   5. 删除结点

### 5.4 压缩和哈夫曼树

1. 文件编码
2. 扩充二叉树
   * 加权路径长度
   * 最优二叉树
3. 哈夫曼树和哈夫曼编码

### 树的存储和操作

1. 树与二叉树的转换
    * 树转换成二叉树(左儿子、右兄弟)
    * 森林转换成二叉树(左儿子、右兄弟) **引入虚根或者直接拼接**
    * 二叉树转换成树
    * 二叉树转换成森林
2. 树的存储结构
    * Father链接结构
    * 儿子链表链接结构
    * 左儿子右兄弟链接结构
3. 树和森林的遍历
    * 先根遍历
    * 后根遍历
    * 层次遍历
4. 树的顺序表示

## 第6章 图

### 6.1 图的基本概念

* G=(V,E)、E(G)、V(G)
* 有向图、无向图
* 度、入度、出度
* 路径、路径的长度、简单路径、简单回路
* 子图、母图、支撑子图
* 可及(连通)、连通图(针对于无向图)、强连通图(针对于有向图)

### 6.2 图的存储结构

* 邻接矩阵
* 邻接表

### 6.3 图的遍历算法

* 深度优先遍历
    * 递归
    * 非递归
* 广度优先遍历

### 6.4 拓扑排序

### 6.5 关键路径

### 6.6 最短路径问题

* 无权最短路径问题
* 正权最短路径问题
  * Dijkstra算法
* 每对顶点之间的最短路径
  * Floyd算法

### 6.7 最小支撑树

* 普里姆(Prim)算法
* 克鲁斯卡尔(Kruskal)算法
    * 适用于求稀疏网络的最小支撑树

## 第7章 排序

* 时间复杂性
  * 关键词的比较次数
  * 数据的移动次数
* 稳定性


### 7.1 插入排序

#### 7.1.1 直接插入排序

算法InsertSort(R,n.R)
FOR j=2 TO n DO
  (
    i=j-1;
    K=K[j];R=R[j];
    WHILE i>0 AND K<K[i] DO
      (R[i+1]=R[i]; i=i-1;)
    R[i+1]=R；
  ) **<span style="color:red">||</span>**

最好：O(n)
最坏：O(n^2)
平均：O(n^2)

**稳定排序算法**

#### 7.1.2 希尔(Shell)排序

思想：把待排序记录按下标的一定增量分组，对每组使用直接插入排序算法，随着增量逐渐减少，每组包含的记录越来越多，当增量值减至1时，整个文件恰好被分成一个组。

**不稳定排序算法**

在小数组(少于50个元素)情况下比快速排序快，对大数组要比快速排序慢。

### 7.2 交换排序

#### 7.2.1 冒泡排序

思想：采用交换的方法，不断交换序列中的反序对，直到不再有反序对为止。

算法BubbleSort(R,n.R)
FOR i=n TO 2 STEP -1 DO
  FOR j=1 TO i-1 DO 
    IF K[j]>K[j+1]
      THEN R[j]<->R[j+1] **<span style="color:red">||</span>**

最好：O(n)
最坏：O(n^2)
平均：O(n^2)
优化：交替冒泡排序

**稳定排序算法**

#### 7.2.2 快速排序

思想：选取待排序文件的某个记录R(如取第一个记录)作为基准元素，然后按照关键词的大小对文件进行重新排列，使得R左边的所有记录的关键词都小于等于R，R右边的记录的关键词都大于R。此时R的位置就是排序之后R在文件中的最终位置。这个过程称为一次分划过程。经过一次分划之后，原来的文件被R划分为左右两个子文件，并且这两个子文件可以单独进行排序。当两个子文件都完成排序后，整个文件也就完成了排序任务。这样就可以递归地对这两个子文件进行排序。

分划操作的时间复杂度：O(n)
最好：O(nlogn)
最坏：O(n^2)（已排好序或者逆序）
平均：O(nlogn)

**不稳定排序算法**

### 7.3 选择排序

#### 7.3.1 直接选择排序

算法SelectSort(R,n.R)
FOR j=n TO 2 STEP -1 DO
  (
    t=1;
    FOR i=2 TO j DO IF K[t]<K[i] THEN t=i;
    R[j]<->R[t];
  ) **<span style="color:red">||</span>**

时间复杂度：O(n^2)

**稳定排序算法**

#### 7.3.2 堆排序

时间复杂度：O(nlogn)

**不稳定排序算法**

### 7.4 合并排序

### 7.5 基于关键词比较的排序算法分析

* 平方阶排序算法及改进算法
* 线性对数阶排序算法
* 分治排序的一般方法
* 基于关键词比较的排序算法下界

## 第8章 查找

### 8.1 顺序查找

* 无序表的顺序查找
  * 成功：(n+1)/2
  * 失败：n+1
* 有序表的顺序查找
  * 成功：(n+1)/2
  * 失败：(n+2)/2

### 8.2 基于关键词比较的查找

* 对半查找
  * 二叉判定树
* 一致对半查找
* 斐波那契查找
* 插值查找

### 8.3 二叉查找树

* 二叉查找树是一棵二叉树，其所有结点之关键词互异，如果按中根顺序对其遍历，则所形成的结点序列对应诸关键词呈递增次序。
* 查找
* 插入
* 删除

### 8.4 散列

散列不仅是一种快速的查找(检索)方法，而且也是一种重要的存储方式。按散列存储方式构造的存储结构称为散列表，散列表中的一个位置称为槽。散列方法的核心是散列函数及冲突消解方法。

* 散列函数
  * 散列函数的设计(便于快速计算)
  * 冲突的解决(极少出现冲突)
  * 散列函数主要设计方法
    1. 压缩法
       * 把关键词的二进制串分隔成若干子串，然后按某种方式把这些子串合并形成该关键词的地址。
    2. 除法散列函数
       * h(K)=K mod M
    3. 乘法散列函数
    4. 平方取中法
    5. 抽取法
* 冲突调节
   1. 拉链法
      * 类似于邻接表
   2. 线性探查法

